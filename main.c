#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, in2,    inLauncher,     sensorReflection)
#pragma config(Sensor, in3,    lightLeft,      sensorReflection)
#pragma config(Sensor, in4,    lightRight,     sensorReflection)
#pragma config(Sensor, dgtl1,  encoder,        sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  launcherReady,  sensorTouch)
#pragma config(Motor,  port2,           LD,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           RD,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           LL1,           tmotorVrex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           liftWall,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           LR1,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           LR2,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           lift,          tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//2500 is the value of inLauncher when a ball is in it. 2700 is the min val for the clog sensors
/**
 * @file    main.c
 * @brief   This file contains the base for competiton code.
 * @details The three sections include Pre-Auton, Auton, and User
 *          Control.
 *
 * @author		Sean Kelley      sgtkode01@gmail.com
 * @author		Bernard Suwirjo  bsuwirjo@gmail.com
 * @author 		Spencer Couture  spence.couture@gmail.com
 * @author		Kyle Moran			 kyle@llamachair.com
 */


#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(120)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

// all functions for competition code
#include "functions.c"



/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Pre-Autonomous
//
/////////////////////////////////////////////////////////////////////////////////////////

/**
 * Period before autonomous when bot cannot move, but minimal code can run
 */
void pre_auton(){
	bStopTasksBetweenModes = true;




}
//get rekt


/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous
//
/////////////////////////////////////////////////////////////////////////////////////////

/**
 * Period of match when bot is using only code to operate.
 */
task autonomous(){
	for(int i=0;i<4;i++){//Will end up launching 4 balls before the end of autonomus

		if(SensorValue[inLauncher] < 2500 && SensorValue[launcherReady] == 1){ //IF LUNCHER IS READY AND BALL IS THERE
			while(SensorValue[lightLeft] < 2700 && SensorValue[lightLeft] < 2700){
				motor[intake] = -90;
			}
			deactivateLauncher();
			motor[intake] = 0;	//====================================================
			wait1Msec(200);			//Stop and reverse the intake to clear unwanted balls
			motor[intake] = -90;//====================================================
			wait1Msec(450);
			motor[intake] = 0;
			wait1Msec(200);
			if(SensorValue[inLauncher] < 2500){//If the ball wasnt a false negitive
				activateLauncher(90);
				wait1Msec(1000);
				deactivateLauncher();
			}else{
				i--; //If the sensor value was a false negitive then restart the process
			}

		}else if(SensorValue[inLauncher] > 2500 && SensorValue[launcherReady] == 1){ //IF LAUNCHER IS READY AND NO BALL IS THERE
			deactivateLauncher();
			motor[intake] = 90;
			i--;
		}else if(SensorValue[inLauncher] < 2500 && SensorValue[launcherReady] == 0){//IF LAUNCHER NOT READY AND BALL IS THERE
			readyLauncher();
			i--;
		}else{
			activateLauncher(90);
			motor[intake] = 90;
			i--;
		}

	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
/////////////////////////////////////////////////////////////////////////////////////////

/**
 * Period of match when driver controls the bot
 */
task usercontrol(){
	startTask(userControlls);
	bool isIntakeOn = false;
	bool isLauncherOn = false;
	bool isIntakeButton = false;
	bool isLauncherButton = false;
  while (true)
	{
    if(bVEXNETActive){
				/////////////////////////////////////////////////////////////////////////////////////////
      //
      //                                      Drive
      //
      /////////////////////////////////////////////////////////////////////////////////////////
  		motor[RD] = vexRT[Ch2]*.9;
  		motor[LD] = vexRT[Ch3]*.9;


			if(vexRT[Btn6D] == 1){
				if(isLauncherButton == false){
					if(isLauncherOn){
						deactivateLauncher();
						isLauncherOn = false;
					}else{
						activateLauncher(90);
						isLauncherOn = true;
					}
					isLauncherButton = true;
				}
			}else{
				if(!isLauncherOn){
					//readyLauncher();
				}
			}
			if(vexRT[Btn5D] == 1){
				if(isIntakeButton == false){
					if(isIntakeOn){
						motor[intake] = 0;
						isIntakeOn = false;
					}else{
						motor[intake] = 90;
						isIntakeOn = true;
					}
					isIntakeButton = true;
				}
			}

			if(vexRT[Btn5U] == 1){
					motor[intake] = -90;
					isIntakeOn = false;
			}

			if(vexRT[Btn7D] == 0 && vexRT[Btn8D] == 0){
				motor[lift] = 0;
			}

			if(vexRT[Btn7L] == 1){
				motor[lift] = -90;
			}

			if(vexRT[Btn7D] == 1){
				motor[lift] = 90;
			}

			if(vexRT[Btn7U] == 1){
				motor[liftWall] = -90;
			}

			if(vexRT[Btn7R] == 1){
				motor[liftWall] = 90;
			}
			if(vexRT[Btn7R] == 0 && vexRT[Btn7U] == 0 ){
				motor[liftWall] = 0;
			}


			if(vexRT[Btn8R] == 1){
				motor[lift] = 90;
				motor[liftWall] = 100;
			}

			if(vexRT[Btn8D] == 1){
				motor[lift] = -90;
				motor[liftWall] = -100;
			}

			if(vexRT[Btn5U] == 0 && motor[intake] == -90){
				motor[intake] = 0;
			}

			if(vexRT[Btn6D] == 0){
				isLauncherButton = false;
			}

			if(vexRT[Btn5D] == 0){
				isIntakeButton = false;
			}

      wait1Msec(10);
    }
	}
}
