#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, in2,    launcherLight,  sensorReflection)
#pragma config(Sensor, in3,    intakeLight,    sensorReflection)
#pragma config(Sensor, dgtl1,  frontSonic,     sensorSONAR_mm)
#pragma config(Sensor, dgtl3,  sideSonicF,     sensorSONAR_mm)
#pragma config(Sensor, dgtl5,  sideSonicB,     sensorSONAR_mm)
#pragma config(Sensor, dgtl7,  bumpLeft,       sensorTouch)
#pragma config(Sensor, dgtl8,  bumpRight,      sensorTouch)
#pragma config(Sensor, dgtl9,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl11, leftEncoder,    sensorQuadEncoder)
#pragma config(Motor,  port2,           LF,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           LB,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           RF,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           RB,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           leftDrive,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           rightDrive,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           intake,        tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"


void pre_auton(){
  bStopTasksBetweenModes = true;
}
//Activates all 4 motors to start the launcher
void activateLauncher(int speed=100){
	motor[LF] = speed;
	motor[LB] = speed;
	motor[RF] = speed;
	motor[RB] = speed;
}

task autonomous(){
	activateLauncher();
}


task usercontrol(){
	while (true){
	  UserControlCodePlaceholderForTesting(); // Remove this function call once you have "real" code.
	  activateLauncher();
	}
}

/**
* Moves forward util a wall is sensed and a certain ultra sonic value is reached
*
* @author Joshua Asari josh.asari@gmail.com
*
* @params  target   Distance away from the wall until the robot stops
*	@params	 power   Drive motor value
*
*/
void forwardsonic(float target, float power=118)
{
	// first 90% of path is at full speed
	while(SensorValue[frontSonic] > target)
		{
			if(SensorValue[frontSonic] > target){
				break;
			}
			sonicDiff = SensorValue[sideSonicF] - SensorValue[sideSonicB];
			if(SensorValue[frontSonic] > target*1.2){
				if(sonicDiff > 10){
					motor[rightDrive] = power;
					motor[leftDrive] = power-5;
			  } else if(sonicDiff < -10) {
			  	motor[rightDrive] = power-5;
					motor[leftDrive] = power;
			  } else {
			  	motor[rightDrive] = power;
					motor[leftDrive] = power;
			  }
			} else if(SensorValue[frontSonic] > target){
				if(sonicDiff > 10){
					motor[rightDrive] = power/2;
					motor[leftDrive] = power/2 - 5;
			  } else if(sonicDiff < -10) {
			  	motor[rightDrive] = power/2 - 5;
					motor[leftDrive] = power/2;
			  } else {
			  	motor[rightDrive] = power/2;
					motor[leftDrive] = power/2;
			  }
			}
		}
	motor[rightDrive] = -power*0.2;
	motor[leftDrive] = -power*0.2;

	wait1Msec(100);

	motor[rightDrive] = 0;
	motor[leftDrive] = 0;
}
